= Java 8 Lambda Expressions
Michael Gfeller <mgf@computas.com>
2016-11-16
:source-highlighter: coderay
:revnumber: {project-version}
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: ../../main/java]

== Motivation and Purpose

* Functional programming is old, but has recently risen in importance.
* Functional programming is good.
* Well suited for concurrent and event-driven programming.
* Java is missing functional programming capabilites.

=== Lambda Expressions

* Java's functional programming constructs.
* Single most important change in Java in recent years.
* Java's version of closures.

=== Key Points

* block of code with parameters that can be _passed around_
* code that can be exuted _later_
* can be converted to functional interfaces
* can access effectively final variables from the enclosing scope

=== Not-so-obvious Consequences

* Method and constructor references refer to methods or constructors without invoking them.
* Default and static methods can be added to interfaces that provide concrete implementations.
* Conflicts between default methods from multiple interfaces must be resolved.

== Syntax

A lambda expression is composed of three parts:

|===
|Argument List|Arrow Token|Body

|(int x, int y)|->|x + y

|===

The body can be a _single expression_ or a _statement block_. 

=== Single Expressions

In the expression form, the body is simply evaluated and returned. 

[source,java]
----
() -> 66
(x,y) -> x + y
(Integer x, Integer y) -> x*y
(x) -> x > 0
----

=== Statement Blocks

In the block form, the body is evaluated like a method body and a return statement returns control to the caller of the anonymous method.

[source,java]
----
(String s) -> { System.out.println(s); } // returns nothing
(String s) -> { 
                 String b = s.toLowerCase(); 
                 System.out.println(b);
                 return b; // returns the lower case string
              }
----

== Functional Interface

* A _functional interface_ defines exactly one abstract method.
* Its signature is called _function descriptor_.
* Lambda expressions can provide _inline_ implementations of functional interfaces.
* Use @FunctionalInterface to indicate the intented use as functional interface, and compile time error checking for this.

=== Functional interfaces in Java 8  

|===
|Functional Interface|Function descriptor

|Predicate<T>        | T -> boolean
|Consumer<T>         | T -> void
|Supplier<T>         | () -> T
|Function<T,R>       | T -> R
//|UnaryOperator<T>    | T -> T

|===

=== More functional interfaces in Java

|===
|Functional Interface|Function descriptor

|Comparator<T>       | (T, T) -> int
|Runnable            | () -> void
|Callable<T>         | () -> T
|FileFilter          | File -> boolean

|===

=== Only _one_ abstract method

[.thumb]
image::functional-interface-comparator-big.jpg[]

Default methods (e.g. _reversed()_) and methods inherited from Object (e.g. _equals_) do not count.

== Examples

[source,java]
----
@FunctionalInterface
interface CheckTrait {
  boolean test(Animal a);
}

static CheckTrait swimmer1 = a -> a.canSwim();
static CheckTrait swimmer2 = (Animal a) -> a.canSwim();
static CheckTrait swimmer3 = (Animal a) -> { return a.canSwim(); };

static Supplier<Animal> creator1 = () -> new Animal();
static Supplier<Animal> creator2 = Animal::new;

animals.add(creator1.get());
animals.stream().forEach(a -> swimmer2.test(a));
animals.stream().filter(a -> a.canSwim() && a.canHop()).count();
animals.stream().forEach(Animal::makeSound);
----

== Questions?

== Tips and best practices

* Java 8 in Action. Urma, Fusco & Mycroft. Manning. 2015.
* http://www.baeldung.com/java-8-lambda-expressions-tips[Lambda Expressions and Functional Interfaces: Tips and Best Practices] by http://www.baeldung.com/[Baeldung]

=== ?

. Prefer standard functional interfaces from https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html[Package java.util.function].
. Use the @FunctionalInterface annotation, even though it is not required. It conveys _intent_ and the compiler can check the contract.
. Don’t Overuse Default Methods in Functional Interfaces. Use sparingly, e.g. for upgrading existing interfaces without breaking backward compatibility.
. Instantiate functional interfaces with lambda expressions instead of inner classes.
. Use static code analysis, and the IDE, to guide you and to refactor.
. Avoid Overloading Methods with Functional Interfaces as Parameters.
. Carefully consider replacing (all) one-method interfaces by @FunctionalInterface and lambda expressions in your whole codebase.
. (Same as previous!) Avoid the temptation to change your whole old codebase to @FunctionalInterface and lambda expressions for all possible existing and custom interfaces with 1 method.
. Don’t write lambda expression code like inner class code.

=== 1. Prefer Standard Functional Interfaces

Prefer standard function interface from https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html[Package java.util.function] instead of 
writing your own interface. For instance

[source,java]
----
@FunctionalInterface
interface lengthConcatable  {
  Integer concatLength(String x, String y);
}
----

is just a function that takes 2 arguments and returns a result, so 

[source,java]
----
BiFunction<String, String, Integer> concatLength = 
  (x, y) -> x.length() + y.length();
----
can be used instead.

=== 2. lambda expressions instead of inner classes

[source,java]
----
// use
BiFunction<String, String, Integer> concatLength =
  (x, y) -> x.length() + y.length();

// instead of 
BiFunction<String, String, Integer> concatLengthInner =
  new BiFunction<String, String, Integer>() {
    @Override
    public Integer apply(String x, String y) {
      return x.length() + y.length();
    }
  };
----

=== Avoid Overloading Methods with Functional Interfaces as Parameters 

[source,java]
----
interface Foo {
  String baz(Function<String, String> f);
  void baz(Consumer<Integer> c);
}

// Ambiguous method call:
public static void main(String[] args) {
  Foo foo = new Baz();
  foo.baz(a -> System.err.println(a));
}
----

=== 7. Don’t write lambda expression code like inner class code.

Difference between lambda expression and inner classes.

Scope! (also_'Refactoring to lambda expressions')
Lambda expressions work with enclosing scope.
Inner classes create their own scope.
_this_ refers to enclosing class in lambde expressions
overriding ('shadowing') local variables is not allowed (?) in lambda expressions.

== Refactoring to lambda expressions

- Inspection in IntelliJ to "Interface may be annotated @FunctionalInterface"
- Inspection in IntelliJ to "Anonymous type can be replaced with lambda"
- Use @FunctionalInterface to denote the intention that its functionality consists of only 1 method
- What are the differences between Lambda and Anonymous Class?
-- this
-- super
-- shadowing
